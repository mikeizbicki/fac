<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>text</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <style>.word-container {
    display: inline-block;
    position: relative;
  }

  .word-hover-span:hover,
  /*.word-speech-bubble:hover,*/
  .word-container:hover .word-hover-span {
    background: yellow;
  }

  .word-speech-bubble {
    position: absolute;
    top: 100%; /* Position right below the word */
    left: 0;
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 5px 10px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    display: none;
    z-index: 9999;
    pointer-events: auto;
    max-width: 20em;
    word-wrap: break-word;
    overflow: hidden;
  }

  /* Show bubble on hover of either word or bubble itself */
  .word-container:hover .word-speech-bubble {
    display: block;
  }</style>
  <script>(function() {
    function initSpeechBubble() {
      try {
        // Create and append speech bubble element
        const speechBubble = document.createElement('div');
        speechBubble.id = 'word-speech-bubble';
        document.body.appendChild(speechBubble);

        // Track the currently active word span
        let activeWordSpan = null;

        // Process text nodes - wrap words in spans
        function processTextNodes() {
          // Get all text-containing elements
          const textElements = document.querySelectorAll('p, h1, h2, h3, h4, h5, h6, span, div, a, li');

          textElements.forEach(function(element) {
            // Skip elements that already have been processed
            if (element.getAttribute('data-word-hover-processed') === 'true') return;
            if (element.closest('script, style')) return; // Skip script and style elements

            element.setAttribute('data-word-hover-processed', 'true');

            // Don't process if this is already a word span we created
            if (element.classList.contains('word-hover-span')) return;

            const text = element.textContent.trim();
            if (!text) return;

            // Don't process elements with no direct text nodes
            let hasDirectTextNode = false;
            for (let i = 0; i < element.childNodes.length; i++) {
              if (element.childNodes[i].nodeType === Node.TEXT_NODE &&
                  element.childNodes[i].textContent.trim()) {
                hasDirectTextNode = true;
                break;
              }
            }
            if (!hasDirectTextNode) return;

            // Replace text nodes with wrapped words
            const childNodes = Array.from(element.childNodes);

            childNodes.forEach(function(node) {
              if (node.nodeType === Node.TEXT_NODE) {
                const words = node.textContent.split(/(\s+)/); // Split by whitespace but keep separators
                const fragment = document.createDocumentFragment();

                words.forEach(function(word) {
                  if (word.trim()) {
                    // Create container for word and its bubble
                    const container = document.createElement('span');
                    container.classList.add('word-container');
                    container.style.display = 'inline-block';
                    container.style.position = 'relative';
                    
                    // Create span for the word
                    const span = document.createElement('span');
                    span.textContent = word;
                    span.classList.add('word-hover-span');
                    
                    // Create bubble for this word
                    const bubble = document.createElement('div');
                    bubble.classList.add('word-speech-bubble');
                    bubble.innerHTML = `<a href="https://www.morfix.co.il/en/${word.trim()}">lookup on morfix.co.il</a>`;
                    
                    // Append everything
                    container.appendChild(span);
                    container.appendChild(bubble);
                    fragment.appendChild(container);
                  } else {
                    // Preserve whitespace
                    fragment.appendChild(document.createTextNode(word));
                  }
                });

                node.parentNode.replaceChild(fragment, node);
              }
            });
          });
        }

        // Handle mouse leaving the word or bubble
        document.addEventListener('mouseover', function(e) {
          if (e.target.classList.contains('word-hover-span')) {
            // Already handled by the mouseenter event
          } else if (e.target !== speechBubble && !speechBubble.contains(e.target)) {
            // Mouse is not over a word span or the bubble
            speechBubble.style.display = 'none';
            activeWordSpan = null;
          }
        });

        // Add event listener to the bubble itself
        speechBubble.addEventListener('mouseleave', function() {
          if (!activeWordSpan) {
            speechBubble.style.display = 'none';
          }
        });

        // Initial setup
        processTextNodes();

        // Setup mutation observer to handle dynamically added content
        const observer = new MutationObserver(function(mutations) {
          processTextNodes();
        });

        observer.observe(document.body, {
          childList: true,
          subtree: true
        });

        console.log('Word speech bubble initialized successfully');
      } catch (error) {
        console.error('Error initializing word speech bubble:', error);
      }
    }

    // Wait for DOM to be fully loaded before initializing
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initSpeechBubble);
    } else {
      // DOM is already ready
      initSpeechBubble();
    }
  })();


  function adjustBubblePosition() {
    document.querySelectorAll('.word-speech-bubble').forEach(bubble => {
      const rect = bubble.getBoundingClientRect();
      const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
      const viewportHeight = window.innerHeight || document.documentElement.clientHeight;

      // Adjust horizontal position if needed
      if (rect.right > viewportWidth) {
        const overflow = rect.right - viewportWidth;
        bubble.style.left = `-${overflow}px`;
      }

      // Adjust vertical position if needed
      if (rect.bottom > viewportHeight) {
        bubble.style.top = 'auto';
        bubble.style.bottom = '100%';
      }
    });
  }

  // Add event listener to check positions on hover
  document.addEventListener('mouseover', function(e) {
    if (e.target.classList.contains('word-hover-span') ||
        e.target.classList.contains('word-speech-bubble')) {
      // Use requestAnimationFrame for performance
      requestAnimationFrame(adjustBubblePosition);
    }
  });</script>
  <style>body {
    font-size: 40pt;
    direction: rtl;
    unicode-bidi: bidi-override;
  }

  h3 + p {
    display: inline-block;
    vertical-align: top;
    width: 50%;
    margin: 0;
    box-sizing: border-box;
  }

  h3 + p + p {
    display: inline-block;
    vertical-align: top;
    width: 45%;
    margin: 0;
    padding-left: 20px;
    box-sizing: border-box;
    text-align: right;
  }

  h3 + p img {
    max-width: 100%;
    height: auto;
  }</style>
  <script>document.addEventListener('keydown', function(event) {
    // Check if arrow keys or page up/down were pressed
    if (event.keyCode === 40 || event.key === 'ArrowDown' ||
        event.keyCode === 38 || event.key === 'ArrowUp' ||
        event.keyCode === 33 || event.key === 'PageUp' ||
        event.keyCode === 34 || event.key === 'PageDown') {

      // Prevent default scrolling behavior
      event.preventDefault();

      // Find the current position
      const scrollPosition = window.scrollY;
      let targetHeading = null;

      // Handle arrow keys (all h tags)
      if (event.keyCode === 40 || event.key === 'ArrowDown' ||
          event.keyCode === 38 || event.key === 'ArrowUp') {
        // Get all heading elements
        const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');

        if (event.keyCode === 40 || event.key === 'ArrowDown') {
          // DOWN ARROW: Find the next heading to scroll to
          for (let i = 0; i < headings.length; i++) {
            const headingPosition = headings[i].getBoundingClientRect().top + window.scrollY;

            // If this heading is below current position, scroll to it
            if (headingPosition > scrollPosition + 10) {
              targetHeading = headings[i];
              break;
            }
          }
        }
        else if (event.keyCode === 38 || event.key === 'ArrowUp') {
          // UP ARROW: Find the previous heading to scroll to
          let previousHeading = null;

          for (let i = 0; i < headings.length; i++) {
            const headingPosition = headings[i].getBoundingClientRect().top + window.scrollY;

            // If this heading is at or above current position (with small buffer)
            if (headingPosition < scrollPosition - 10) {
              previousHeading = headings[i];
            } else {
              break; // We've gone past the current position
            }
          }

          // If we found a previous heading, use it
          if (previousHeading) {
            targetHeading = previousHeading;
          }
        }
      }
      // Handle Page Up/Down (only h2 tags)
      else if (event.keyCode === 33 || event.key === 'PageUp' ||
               event.keyCode === 34 || event.key === 'PageDown') {
        // Get only h2 elements
        const h2Headings = document.querySelectorAll('h2');

        if (event.keyCode === 34 || event.key === 'PageDown') {
          // PAGE DOWN: Find the next h2 to scroll to
          for (let i = 0; i < h2Headings.length; i++) {
            const headingPosition = h2Headings[i].getBoundingClientRect().top + window.scrollY;

            // If this h2 is below current position, scroll to it
            if (headingPosition > scrollPosition + 10) {
              targetHeading = h2Headings[i];
              break;
            }
          }
        }
        else if (event.keyCode === 33 || event.key === 'PageUp') {
          // PAGE UP: Find the previous h2 to scroll to
          let previousHeading = null;

          for (let i = 0; i < h2Headings.length; i++) {
            const headingPosition = h2Headings[i].getBoundingClientRect().top + window.scrollY;

            // If this h2 is at or above current position (with small buffer)
            if (headingPosition < scrollPosition - 10) {
              previousHeading = h2Headings[i];
            } else {
              break; // We've gone past the current position
            }
          }

          // If we found a previous h2, use it
          if (previousHeading) {
            targetHeading = previousHeading;
          }
        }
      }

      // Scroll to the target heading if one was found
      if (targetHeading) {
        //targetHeading.scrollIntoView({behavior: 'smooth'});
        targetHeading.scrollIntoView({behavior: 'instant'});
      }
    }
  });</script>
</head>
<body>
<h2 id="chapter-0-עבודת-הילדים-הקשה">Chapter 0: עֲבוֹדַת הַיְלָדִים הַקָּשָׁה</h2>
<h3 id="section-0-none">Section 0: None</h3>
</body>
</html>
